/**************************************************************************
 * @file     	IMU_onBoard.c
 * @brief    	板载陀螺仪磁力计读取
 * @writer		外部引用
 **************************************************************************/
#include "IMU_onBoard.h"
#include "IST8310_reg.h"
#include "mpu6500_reg.h"
//#include "spi5.h"
#include <math.h>

#define IMU_FLATWISE 1

static float Kp = 2.0f, Ki = 0.01f, halfT = ((float)(2/2000.0f));
volatile static float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;
IMUDataTypedef imu_data = {0,0,0,0,0,0,0,0,0,0}; //校准&原始数据
IMUTypedef imu_; //输出数据

float inv_sqrt(float x);
uint8_t MPU6500_Write_Reg(uint8_t const reg, uint8_t const data);
uint8_t MPU6500_Read_Reg(uint8_t const reg);
uint8_t MPU6500_Set_Accel_Fsr(uint8_t fsr); //Set the accelerated velocity resolution
uint8_t MPU6500_Set_Gyro_Fsr(uint8_t fsr); //Set the angular velocity resolution

/**
  * @name 	mpu_offset_call()
  * @brief 	陀螺仪零偏校准，使用简单的均值校准
  * @param	None
  * @return None
  */
void mpu_offset_call() {
    uint8_t mpu_buff[20];
    int i;

    for(i = 0; i < 300; i++) {
        MPU6500=0;
        SPI5_ReadWriteByte(MPU6500_ACCEL_XOUT_H|0x80);
        mpu_buff[0]=MPU6500_Read_Reg(MPU6500_ACCEL_XOUT_H);
        mpu_buff[1]=MPU6500_Read_Reg(MPU6500_ACCEL_XOUT_L);
        mpu_buff[2]=MPU6500_Read_Reg(MPU6500_ACCEL_YOUT_H);
        mpu_buff[3]=MPU6500_Read_Reg(MPU6500_ACCEL_YOUT_L);
        mpu_buff[4]=MPU6500_Read_Reg(MPU6500_ACCEL_ZOUT_H);
        mpu_buff[5]=MPU6500_Read_Reg(MPU6500_ACCEL_ZOUT_L);

        mpu_buff[6]=MPU6500_Read_Reg(MPU6500_TEMP_OUT_H);
        mpu_buff[7]=MPU6500_Read_Reg(MPU6500_TEMP_OUT_L);

        mpu_buff[8]=MPU6500_Read_Reg(MPU6500_GYRO_XOUT_H);
        mpu_buff[9]=MPU6500_Read_Reg(MPU6500_GYRO_XOUT_L);
        mpu_buff[10]=MPU6500_Read_Reg(MPU6500_GYRO_YOUT_H);
        mpu_buff[11]=MPU6500_Read_Reg(MPU6500_GYRO_YOUT_L);
        mpu_buff[12]=MPU6500_Read_Reg(MPU6500_GYRO_ZOUT_H);
        mpu_buff[13]=MPU6500_Read_Reg(MPU6500_GYRO_ZOUT_L);
        MPU6500=1;
        imu_data.az_offset += mpu_buff[0]<<8 |mpu_buff[1];
        imu_data.ay_offset += mpu_buff[2]<<8 |mpu_buff[3];
        imu_data.ax_offset += mpu_buff[4]<<8 |mpu_buff[5];
        imu_data.temp_offset += mpu_buff[6]<<8 |mpu_buff[7];
        imu_data.gz_offset += mpu_buff[8]<<8 |mpu_buff[9];
        imu_data.gy_offset += mpu_buff[10]<<8 |mpu_buff[11];
        imu_data.gx_offset += mpu_buff[12]<<8 |mpu_buff[13];
        vTaskDelay(5);
    }
    imu_data.ay_offset = imu_data.ay_offset/300;
    imu_data.gy_offset = imu_data.gy_offset/300;

#if IMU_STELLEN
    imu_data.ax_offset = imu_data.ax_offset/300;
    imu_data.az_offset = imu_data.az_offset/300;
    imu_data.gx_offset = imu_data.gx_offset/300;
    imu_data.gz_offset = imu_data.gz_offset/300;
#elif IMU_FLATWISE
    imu_data.az_offset = imu_data.ax_offset/300;
    imu_data.ax_offset = imu_data.az_offset/300;
    imu_data.gz_offset = imu_data.gx_offset/300;
    imu_data.gx_offset = imu_data.gz_offset/300;
#endif
}

//Write IST8310 register through MPU6500
static void IST_Reg_Write_By_MPU(uint8_t addr, uint8_t data)
{
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_CTRL, 0x00);
  vTaskDelay(2);
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_REG, addr);
  vTaskDelay(2);
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_DO, data);
  vTaskDelay(2);
  
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_CTRL, 0x080 | 0x01);
  vTaskDelay(10);
}

//Write IST8310 register through MPU6500
static uint8_t IST_Reg_Read_By_MPU(uint8_t addr)
{
  uint8_t data;
  
  MPU6500_Write_Reg(MPU6500_I2C_SLV4_REG, addr);
  vTaskDelay(10);
  MPU6500_Write_Reg(MPU6500_I2C_SLV4_CTRL, 0x80);
  vTaskDelay(10);
  data = MPU6500_Read_Reg(MPU6500_I2C_SLV4_DI);
  MPU6500_Write_Reg(MPU6500_I2C_SLV4_CTRL, 0x00);
  vTaskDelay(10);
  return data;
}

//Initialize the MPU6500 I2C Slave0 for I2C reading
static void MPU_Auto_Read_IST_config(uint8_t device_address, uint8_t reg_base_addr, uint8_t data_num)
{
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_ADDR, device_address);
  vTaskDelay(2);
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_REG, IST8310_R_CONFA);
  vTaskDelay(2);
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_DO, IST8310_ODR_MODE);
  vTaskDelay(2);
  
  MPU6500_Write_Reg(MPU6500_I2C_SLV0_ADDR, 0x80 | device_address);
  vTaskDelay(2);
  MPU6500_Write_Reg(MPU6500_I2C_SLV0_REG, reg_base_addr);
  vTaskDelay(2);
  
  MPU6500_Write_Reg(MPU6500_I2C_SLV4_CTRL, 0x03);
  vTaskDelay(2);
  
  MPU6500_Write_Reg(MPU6500_I2C_MST_DELAY_CTRL, 0x01 | 0x02);
  vTaskDelay(2);
  
  MPU6500_Write_Reg(MPU6500_I2C_SLV1_CTRL, 0x80 | 0x01);
  vTaskDelay(6);
  
  MPU6500_Write_Reg(MPU6500_I2C_SLV0_CTRL, 0x80 | data_num);
  vTaskDelay(7);
}

uint8_t IST8310_Init(void)
{
    MPU6500_Write_Reg(MPU6500_USER_CTRL, 0x30);
    vTaskDelay(10);
    MPU6500_Write_Reg(MPU6500_I2C_MST_CTRL, 0x0d);
    vTaskDelay(10);

    MPU6500_Write_Reg(MPU6500_I2C_SLV1_ADDR, IST8310_ADDRESS);
    vTaskDelay(10);
    MPU6500_Write_Reg(MPU6500_I2C_SLV4_ADDR, 0x80 | IST8310_ADDRESS);
    vTaskDelay(10);

    IST_Reg_Write_By_MPU(IST8310_R_CONFB, 0x01);
    if(IST8310_DEVICE_ID_A != IST_Reg_Read_By_MPU(IST8310_WHO_AM_I))
        return 1; //error
    vTaskDelay(10);

    IST_Reg_Write_By_MPU(IST8310_R_CONFA, 0x00);
    if(IST_Reg_Read_By_MPU(IST8310_R_CONFA) != 0x00)
        return 2;
    vTaskDelay(10);

    IST_Reg_Write_By_MPU(IST8310_R_CONFB, 0x00);
    if(IST_Reg_Read_By_MPU(IST8310_R_CONFB) != 0x00)
        return 3;
    vTaskDelay(10);

    IST_Reg_Write_By_MPU(IST8310_AVGCNTL, 0x24);
    if(IST_Reg_Read_By_MPU(IST8310_AVGCNTL) != 0x24)
        return 4;
    vTaskDelay(10);

    IST_Reg_Write_By_MPU(IST8310_PDCNTL, 0xc0);
    if(IST_Reg_Read_By_MPU(IST8310_PDCNTL) != 0xc0)
        return 5;
    vTaskDelay(10);

    MPU6500_Write_Reg(MPU6500_I2C_SLV1_CTRL, 0x00);
    vTaskDelay(10);
    MPU6500_Write_Reg(MPU6500_I2C_SLV4_CTRL, 0x00);
    vTaskDelay(10);

    MPU_Auto_Read_IST_config(IST8310_ADDRESS, IST8310_R_XL, 0x06);
    vTaskDelay(100);
    return 0;
}

/**
  * @name 	MPU6500_Init()
  * @brief 	板载陀螺仪MPU6500初始化
  * @param	None
  * @return None
  */
uint8_t MPU6500_Init(void)
{
    Spi5_Init();
    uint8_t index = 0;
    uint8_t MPU6500_Init_Data[10][2] =
    {
        {MPU6500_PWR_MGMT_1,    0x80},      // Reset Device
        {MPU6500_PWR_MGMT_1,    0x03},      // Clock Source - Gyro-Z
        {MPU6500_PWR_MGMT_2,    0x00},      // Enable Acc & Gyro
        {MPU6500_CONFIG,        0x04},      // LPF 41Hz
        {MPU6500_GYRO_CONFIG,   0x18},      // +-2000dps
        {MPU6500_ACCEL_CONFIG,  0x10},      // +-8G
        {MPU6500_ACCEL_CONFIG_2,0x02},      // enable LowPassFilter  Set Acc LPF
        {MPU6500_USER_CTRL,     0x20},      // Enable AUX
    };

    vTaskDelay(100);
    uint8_t MPU_id = MPU6500_Read_Reg(MPU6500_WHO_AM_I);  //read id of device,check if MPU6500 or not 修改过读取函数

    for(index = 0; index < 10; index++)
    {
        MPU6500_Write_Reg(MPU6500_Init_Data[index][0], MPU6500_Init_Data[index][1]);
        vTaskDelay(1);
    }

    IST8310_Init();

    MPU6500_Set_Gyro_Fsr(3);
//    00 = ±250dps
//    01= ±500dps
//    10 = ±1000dps
//    11 = ±2000dps
    MPU6500_Set_Accel_Fsr(2);
//    ±2g (00), ±4g (01), ±8g (10), ±16g (11)
    mpu_offset_call();
    return 0;
}

/**
  * @name 	IMU_Get_Data()
  * @brief 	获取陀螺仪数据，保存在imu_data结构体中
  * @param	None
  * @return None
  */
void IMU_Get_Data()
{
    uint8_t mpu_buff[20];
    MPU6500=0;
    //读取陀螺仪数据
    SPI5_ReadWriteByte(MPU6500_ACCEL_XOUT_H|0x80);
    mpu_buff[0]=MPU6500_Read_Reg(MPU6500_ACCEL_XOUT_H);
    mpu_buff[1]=MPU6500_Read_Reg(MPU6500_ACCEL_XOUT_L);
    mpu_buff[2]=MPU6500_Read_Reg(MPU6500_ACCEL_YOUT_H);
    mpu_buff[3]=MPU6500_Read_Reg(MPU6500_ACCEL_YOUT_L);
    mpu_buff[4]=MPU6500_Read_Reg(MPU6500_ACCEL_ZOUT_H);
    mpu_buff[5]=MPU6500_Read_Reg(MPU6500_ACCEL_ZOUT_L);
    mpu_buff[6]=MPU6500_Read_Reg(MPU6500_TEMP_OUT_H);
    mpu_buff[7]=MPU6500_Read_Reg(MPU6500_TEMP_OUT_L);
    mpu_buff[8]=MPU6500_Read_Reg(MPU6500_GYRO_XOUT_H);
    mpu_buff[9]=MPU6500_Read_Reg(MPU6500_GYRO_XOUT_L);
    mpu_buff[10]=MPU6500_Read_Reg(MPU6500_GYRO_YOUT_H);
    mpu_buff[11]=MPU6500_Read_Reg(MPU6500_GYRO_YOUT_L);
    mpu_buff[12]=MPU6500_Read_Reg(MPU6500_GYRO_ZOUT_H);
    mpu_buff[13]=MPU6500_Read_Reg(MPU6500_GYRO_ZOUT_L);

    imu_data.ay = (mpu_buff[2]<<8 |mpu_buff[3]) - imu_data.ay_offset;
    imu_data.gy = (mpu_buff[10]<<8 |mpu_buff[11]) - imu_data.gy_offset;
    imu_data.temp = mpu_buff[6]<<8 |mpu_buff[7];

#if IMU_STELLEN //使用板载陀螺仪竖直放置此宏定义为1
    imu_data.az = (mpu_buff[0]<<8 |mpu_buff[1]) - imu_data.az_offset;
    imu_data.ax = (mpu_buff[4]<<8 | mpu_buff[5]) - imu_data.ax_offset;
    imu_data.gz = (mpu_buff[8]<<8 |mpu_buff[9]) - imu_data.gz_offset;
    imu_data.gx = (mpu_buff[12]<<8 |mpu_buff[13]) - imu_data.gx_offset;
#elif IMU_FLATWISE //使用板载陀螺仪水平放置此宏定义为1
    imu_data.ax = (mpu_buff[0]<<8 |mpu_buff[1]) - imu_data.ax_offset;
    imu_data.az = (mpu_buff[4]<<8 | mpu_buff[5]) - imu_data.az_offset;
    imu_data.gx = (mpu_buff[8]<<8 |mpu_buff[9]) - imu_data.gx_offset;
    imu_data.gz = (mpu_buff[12]<<8 |mpu_buff[13]) - imu_data.gz_offset;
#endif

    MPU6500=1;

    imu_.ax = imu_data.ax;
    imu_.ay = imu_data.ay;
    imu_.az = imu_data.az;
    imu_.temp = 21 + imu_data.temp / 333.87f;
    /*2000dps -> °/s*/
    imu_.vx = imu_data.gx / 16.384f;
    imu_.vy = imu_data.gy / 16.384f;
    imu_.vz = imu_data.gz / 16.384f;
    /* °/s -> rad/s */
    imu_.wx = imu_.vx / 57.3f;
    imu_.wy = imu_.vy / 57.3f;
    imu_.wz = imu_.vz / 57.3f;
}

/**
  * @name 	imu_ahrs_update()
  * @brief 	根据MPU6500的角速度和角度信息以及前后两次积分的时间更新四元数
  * @reference https://blog.csdn.net/sddxseu/article/details/53414501
  * @reference https://github.com/xioTechnologies/Open-Source-AHRS-With-x-IMU/blob/master/x-IMU%20IMU%20and%20AHRS%20Algorithms/x-IMU%20IMU%20and%20AHRS%20Algorithms/AHRS/MahonyAHRS.cs
  * @param	None
  * @return None
  */
void imu_ahrs_update(void) {
    volatile float gx, gy, gz, ax, ay, az, mx, my, mz; //传感器原始数据
    float norm;
    float hx, hy, bx, bz;
    float vx, vy, vz, wx, wy, wz;
    float ex, ey, ez;
    static float exInt, eyInt, ezInt;
    float tempq0, tempq1, tempq2, tempq3;

    float q0q0 = q0*q0;
    float q0q1 = q0*q1;
    float q0q2 = q0*q2;
    float q0q3 = q0*q3;
    float q1q1 = q1*q1;
    float q1q2 = q1*q2;
    float q1q3 = q1*q3;
    float q2q2 = q2*q2;
    float q2q3 = q2*q3;
    float q3q3 = q3*q3;

    gx = imu_.wx;   //Gyro X axis
    gy = imu_.wy;   //Gyro Y axis
    gz = imu_.wz;   //Gyro Z axis
    ax = imu_.ax;   //Acce X axis
    ay = imu_.ay;   //Acce Y axis
    az = imu_.az;   //Acce Z axis
    mx = 0;         //Magn X axis
    my = 0;         //Magn Y axis
    mz = 0;         //Magn Z axis

    // Normalise accelerometer measurement 归一化加速度计测量
    if(!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) { //全为0时则不计算
        norm = inv_sqrt(ax*ax + ay*ay + az*az);
        ax *= norm;
        ay *= norm;
        az *= norm;
    }
    // Normalise accelerometer measurement 归一化地磁计测量
    if(!((mx == 0.0f) && (my == 0.0f) && (mz == 0.0f))) { //全为0时则不计算
        norm = inv_sqrt(mx*mx + my*my + mz*mz);
        mx *= norm;
        my *= norm;
        mz *= norm;
    }

    // Reference direction of Earth's magnetic field 地球磁场的参考方向
    hx = 2.0f*mx*(0.5f - q2q2 - q3q3) + 2.0f*my*(q1q2 - q0q3) + 2.0f*mz*(q1q3 + q0q2);
    hy = 2.0f*mx*(q1q2 + q0q3) + 2.0f*my*(0.5f - q1q1 - q3q3) + 2.0f*mz*(q2q3 - q0q1);
    bx = sqrt((hx*hx) + (hy*hy));
    bz = 2.0f*mx*(q1q3 - q0q2) + 2.0f*my*(q2q3 + q0q1) + 2.0f*mz*(0.5f - q1q1 - q2q2);

    // Estimated direction of gravity and magnetic field 估计的重力和磁场方向
    vx = 2.0f*(q1q3 - q0q2);
    vy = 2.0f*(q0q1 + q2q3);
    vz = q0q0 - q1q1 - q2q2 + q3q3;
    wx = 2.0f*bx*(0.5f - q2q2 - q3q3) + 2.0f*bz*(q1q3 - q0q2);
    wy = 2.0f*bx*(q1q2 - q0q3) + 2.0f*bz*(q0q1 + q2q3);
    wz = 2.0f*bx*(q0q2 + q1q3) + 2.0f*bz*(0.5f - q1q1 - q2q2);

    /*
     * error is sum of cross product between reference direction
     * of fields and direction measured by sensors
     * 误差是场的参考方向和传感器测量的方向之间的叉积之和
     */
    ex = (ay*vz - az*vy) + (my*wz - mz*wy);
    ey = (az*vx - ax*vz) + (mz*wx - mx*wz);
    ez = (ax*vy - ay*vx) + (mx*wy - my*wx);
    float Kp = 2.0f, Ki = 0.01f;
    if (Ki > 0.0f) { // accumulate integral error 误差积分
        exInt += ex;
        eyInt += ey;
        ezInt += ez;
    }
    else { // prevent integral wind up 积分清零
        exInt = 0.0f;
        eyInt = 0.0f;
        ezInt = 0.0f;
    }

    // Apply feedback terms 应用负反馈
    gx += Kp * ex + Ki * exInt;
    gy += Kp * ey + Ki * eyInt;
    gz += Kp * ez + Ki * ezInt;

    // Integrate rate of change of quaternion 积分四元数变化率
    tempq0 = q0 + (-q1*gx - q2*gy - q3*gz) * halfT;
    tempq1 = q1 + (q0*gx + q2*gz - q3*gy) * halfT;
    tempq2 = q2 + (q0*gy - q1*gz + q3*gx) * halfT;
    tempq3 = q3 + (q0*gz + q1*gy - q2*gx) * halfT;

    // Normalise quaternion 归一化输出
    norm = inv_sqrt(tempq0*tempq0 + tempq1*tempq1 + tempq2*tempq2 + tempq3*tempq3);
    q0 = tempq0 * norm;
    q1 = tempq1 * norm;
    q2 = tempq2 * norm;
    q3 = tempq3 * norm;
}

void imu_ahrs_update2(void) {
    volatile float gx, gy, gz, ax, ay, az; //传感器原始数据
    float norm;
    float vx, vy, vz;
    float ex, ey, ez;
    static float exInt, eyInt, ezInt;
    float tempq0, tempq1, tempq2, tempq3;

    float q0q0 = q0*q0;
    float q0q1 = q0*q1;
    float q0q2 = q0*q2;
    float q0q3 = q0*q3;
    float q1q1 = q1*q1;
    float q1q2 = q1*q2;
    float q1q3 = q1*q3;
    float q2q2 = q2*q2;
    float q2q3 = q2*q3;
    float q3q3 = q3*q3;

    gx = imu_.wx;   //Gyro X axis
    gy = imu_.wy;   //Gyro Y axis
    gz = imu_.wz;   //Gyro Z axis
    ax = imu_.ax;   //Acce X axis
    ay = imu_.ay;   //Acce Y axis
    az = imu_.az;   //Acce Z axis

    // Normalise accelerometer measurement 归一化加速度计测量
    if(!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) { //全为0时则不计算
        norm = inv_sqrt(ax*ax + ay*ay + az*az);
        ax *= norm;
        ay *= norm;
        az *= norm;
    }

    // Estimated direction of gravity 估计的重力方向
    vx = 2.0f*(q1q3 - q0q2);
    vy = 2.0f*(q0q1 + q2q3);
    vz = q0q0 - q1q1 - q2q2 + q3q3;

    /*
     * error is sum of cross product between reference direction
     * of fields and direction measured by sensors
     * 误差是场的参考方向和传感器测量的方向之间的叉积之和
     */
    ex = (ay*vz - az*vy);
    ey = (az*vx - ax*vz);
    ez = (ax*vy - ay*vx);

    if (Ki > 0.0f) { // accumulate integral error 误差积分
        exInt += ex;
        eyInt += ey;
        ezInt += ez;
    }
    else { // prevent integral wind up 积分清零
        exInt = 0.0f;
        eyInt = 0.0f;
        ezInt = 0.0f;
    }

    // Apply feedback terms 应用负反馈
    gx += Kp * ex + Ki * exInt;
    gy += Kp * ey + Ki * eyInt;
    gz += Kp * ez + Ki * ezInt;

    // Integrate rate of change of quaternion 积分四元数变化率
    tempq0 = q0 + (-q1*gx - q2*gy - q3*gz) * halfT;
    tempq1 = q1 + (q0*gx + q2*gz - q3*gy) * halfT;
    tempq2 = q2 + (q0*gy - q1*gz + q3*gx) * halfT;
    tempq3 = q3 + (q0*gz + q1*gy - q2*gx) * halfT;

    // Normalise quaternion 归一化输出
    norm = inv_sqrt(tempq0*tempq0 + tempq1*tempq1 + tempq2*tempq2 + tempq3*tempq3);
    q0 = tempq0 * norm;
    q1 = tempq1 * norm;
    q2 = tempq2 * norm;
    q3 = tempq3 * norm;
}
/**
  * @name 	imu_attitude_update()
  * @brief 	根据四元数，获取欧拉角
  * @param	None
  * @return None
  */
void imu_attitude_update(void)
{
    /* yaw    -pi----pi */
    imu_.yaw = -atan2(2*q1*q2 + 2*q0*q3, -2*q2*q2 - 2*q3*q3 + 1)* 57.2957795;
    /* pitch  -pi/2----pi/2 */
    imu_.pit = -asin(-2*q1*q3 + 2*q0*q2)* 57.2957795;
    /* roll   -pi----pi  */
    imu_.rol =  atan2(2*q2*q3 + 2*q0*q1, -2*q1*q1 - 2*q2*q2 + 1)* 57.2957795;
}

/**
  * @brief  fast inverse square-root, to calculate 1/Sqrt(x)
  * @param  x: the number need to be calculated
  * @retval 1/Sqrt(x)
  * @usage  call in imu_ahrs_update() function
  */
float inv_sqrt(float x)
{
    float halfx = 0.5f * x;
    float y     = x;
    long  i     = *(long*)&y;

    i = 0x5f3759df - (i >> 1);
    y = *(float*)&i;
    y = y * (1.5f - (halfx * y * y));

    return y;
}

uint8_t MPU6500_Write_Reg(uint8_t const reg, uint8_t const data)
{
    static uint8_t MPU_Tx;

    MPU6500=0;

    MPU_Tx = reg&0x7f;
    SPI5_ReadWriteByte(MPU_Tx);
    MPU_Tx = data;
    SPI5_ReadWriteByte(MPU_Tx);

    MPU6500=1;
    return 0;
}

uint8_t MPU6500_Read_Reg(uint8_t const reg)
{
    static uint8_t MPU_Rx, MPU_Tx;
    MPU_Tx = reg|0x80;
    MPU_Rx=SPI5_ReadWriteByte(MPU_Tx);
    return  MPU_Rx;
}

//Set the accelerated velocity resolution
uint8_t MPU6500_Set_Accel_Fsr(uint8_t fsr)
{
    return MPU6500_Write_Reg(MPU6500_ACCEL_CONFIG, fsr<<3);
}

//Set the angular velocity resolution
uint8_t MPU6500_Set_Gyro_Fsr(uint8_t fsr)
{
    return MPU6500_Write_Reg(MPU6500_GYRO_CONFIG, fsr<<3);
}
